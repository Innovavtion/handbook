## Selectors (Селекторы)

[источник](https://code.tutsplus.com/ru/tutorials/the-30-css-selectors-you-must-memorize--net-16048)

**Селекторы** - это выражения, которые говорят браузеру, к какому элементу HTML нужно применить те или иные свойства CSS, определённые внутри блока объявления стиля.

**Псевдокласс** - это ключевое слово, добавленное к селектору, которое определяет его особое состояние. пример - **`:active`**

**Псевдоэлемент** - это ключевое слово, добавляемое к селектору, которое позволяет стилизовать определённую часть выбранного элемента. Например, псевдоэлемент `::first-line` может быть использован для изменения шрифта первой строки абзаца.

**Полезные Селекторы и Псевдоклассы**:

1. **Контекстный** - Он используется для выбора элементов, удовлетворяющих определённому контексту. Например, вместо того, чтобы задавать стиль всем ссылкам, вам нужно изменить отображение только тех ссылок, которые расположены внутри несортированного списка.

```css
li a {
  text-decoration: none;
}
```

2. **Псевдокласс `X:visited и X:link`** - используется для стилизации ссылок

```css
/* стили для ссылки на которую еще не нажал пользователь */
a:link {
  color: red;
}

/* стили для ссылки на которую пользователь уже нажал */
a:visted {
  color: purple;
}
```

3. **`X + Y`** - это соседний селектор. Он поможет нам выбрать только тот элемент, который следует сразу же за указанным элементом. В этом примере мы выберем только первый параграф текста, следующий сразу за тэгом ul.

```css
ul + p {
  color: red;
}
```

4. **`X > Y`** - Разница между селекторами X Y и X > Y в том, что в последнем примере мы выберем только прямого потомка.
   Селектор **#container > ul** выберет только тот элемент **ul**, который является прямым потомком элемента **div** с **id** равным **container**. Он не выберет, например, элемент ul , являющийся потомком первого элемента li.
   Данный способ выбора элементов является очень эффективным. Рекомендую вам использовать его, особенно при работе с JavaScript.

```css
div#container > ul {
  border: 1px solid black;
}

/* HTML структура*/
<div id="container">
    <ul> <- Возьмет только этот
       <li> List Item
         <ul>
            <li> Child </li>
         </ul>
       </li>
       <li> List Item </li>
       <li> List Item </li>
       <li> List Item </li>
    </ul>
</div>
```

5. **`X ~ Y`** - этот селектор похож на X + Y, но он менее строгий. Соседний селектор (ul + p) выберет только первый элемент, следующий сразу же за указанным элементом. Селектор X ~ Y выберет все элементы p, расположенные после элемента ul.

```css
ul ~ p {
  color: red;
}
```

6. **`X[title]`** - Это селектор атрибутов. Он выберет только те ссылки, у которых имеется указанный атрибут title.

```css
a[title] {
  color: green;
}
```

7. **`X[href="foo"]`** - Указанный выше код выберет все ссылки, указывающие на `http://net.tutsplus.com`. Они окрасятся в зелёный цвет. Стиль остальных ссылок останется без изменений.
   Этот метод отлично работает, но он слишком строгий. Что, если ссылка указывает на Nettuts+, но путь прописан как `nettuts.com`? В этом случае мы можем использовать синтаксис регулярных выражений.

> Не забудьте, что значение атрибута нужно заключать в кавычки. Особенно внимательны будьте при использовании JavaScript.

8. **`X[href*="nettuts"]`** - Звёздочка означает, что указанное значение должно быть частью указанного атрибута. Поэтому этот селектор выберет и `nettuts.com`, и `net.tutsplus.com`, и даже `tutsplus.com`.
   Но помните, что этот способ слишком обширен. Что, если у вас будет ссылка, не указывающая на tuts+, но имеющая в адресе слово tuts? Для составления более строго правила используйте **^** и **$**, указывающие на начало и конец строки соответственно.

```css
a[href*="tuts"] {
  color: #1f6053; /* nettuts green */
}
```

9. **`X[href^="http"]`** - В регулярных выражениях он используется для указания начала строки. Если мы хотим выбрать все ссылки, начинающиеся с http, то мы можем использовать код из примера сверху.

```css
a[href^="http"] {
  background: url(path/to/external/icon.png) no-repeat;
  padding-left: 10px;
}
```

10. **`X[href$=".jpg"]`** - Мы используем символ из регулярных выражений $, который указывает на конец строки. В этом случае мы ищем все ссылки на фото, т.е. путь в них должен заканчиваться на .jpg. Учтите, что это не сработает для файлов gif и png.

```css
a[href$=".jpg"] {
  color: red;
}
```

11. **`X[data-*="foo"]`** - Как же нам выбрать все типы изображений, включая png, jpeg,jpg, gif? Мы можем добавить атрибут data-filetype к каждой ссылке, указывающей на изображение.

```css
/* html структура */
/*<a href="path/to/image.jpg" data-filetype="image"> Image Link </a>*/

/*Теперь мы можем использовать селектор атрибутов для выбора только этих ссылок.*/
a[data-filetype="image"] {
  color: red;
}
```

12. **`X[foo~="bar"]`** - Символ тильда (**~**) позволяет выбрать атрибут, в котором есть значения, разделённые пробелом.
    Теперь мы можем создать атрибут **data-info** и использовать в нём любые значения, разделяя их пробелами. Для примера укажем, что ссылка у нас внешняя и ведёт на изображение.
    Этот код позволит нам выбрать любой элемент, имеющий в качестве значения атрибута любое нужное нам слово.

```css
/* html структура */
<a href="path/to/image.jpg" data-info="external image"> Нажми на меня, дурашка </a>

/* Выбираем атрибут data-info со значением "external" */
a[data-info~="external"] {
  color: red;
}
/* Выбираем атрибут со значчением "image" */
a[data-info~="image"] {
  border: 1px solid black;
}
```

13. **`X:checked`** - Данный псевдокласс выберет только отмеченные элементы пользовательского интерфейса: радиокнопки или чекбоксы.

```css
input[type="radio"]:checked {
  border: 1px solid black;
}
```

14. **`X:after`** - Псевдоклассы before и after сейчас очень популярны. Каждый день разработчики находят новые оригинальные способы их использования. Эти псевдоклассы позволяют нам сгенерировать контент вокруг указанного элемента.
    Этот хак использует псевдокласс :after для добавления пробела после элемента. Обязательно занесите этот трюк в свою копилку знаний. Он особенно полезен там, где нельзя использовать overflow: hidden;
    Многие впервые знакомятся с этими псевдоклассами при изучении хака **clear-fix**.

```css
.clearfix:after {
  content: "";
  display: block;
  clear: both;
  visibility: hidden;
  font-size: 0;
  height: 0;
}
.clearfix {
  *display: inline-block;
  _height: 1%;
}
```

15. **`X:not(selector)`** - Псевдокласс отрицания бывает очень полезен. Представьте, что вам нужно выбрать все тэги div, кроме одного с id равным container. Код ниже сделает именно это.

```css
div:not(#container) {
  color: blue;
}
```

16. **`X:pseudoElement`** - Мы можем использовать псевдоэлементы (отделённые символом `::`) для стилизации части элемента: первой строки параграфа или первой буквы. Помните, что псевдоэлементы будут работать только с блоковыми элементами.

```css
/* Выберет первую букву параграфа */
p::first-letter {
  float: left;
  font-size: 2em;
  font-weight: bold;
  font-family: cursive;
  padding-right: 2px;
}

/* Выберет первую строку параграфа */
p::first-line {
  font-weight: bold;
  font-size: 1.2em;
}
```
