**Hook useEffect (Хуки Эффекта)** используется вместо `componentDidMount - запускается после того, как компонент отрендерился в DOM` и `componentDidUpdate - вызывается сразу после обновления, не вызывается при первом рендере`.

**Использование хука `useEffect`:**

1. **Что же делает `useEffect`?**
   Используя этот хук, вы говорите React сделать что-то после рендера. React запомнит функцию (то есть «эффект»), которую вы передали и вызовет её после того, как внесёт все изменения в DOM. В этом эффекте мы устанавливаем заголовок документа, но мы также можем выполнить запрос данных или вызвать какой-нибудь императивный API.
2. **Почему же мы вызываем `useEffect` непосредственно внутри компонента?**
   Это даёт нам доступ к переменной состояния `count` (или любым другим пропсам) прямиком из эффекта. Нам не нужен специальный API для доступа к этой переменной — она уже находится у нас в области видимости функции. Хуки используют JavaScript-замыкания, и таким образом, им не нужен специальный API для React, поскольку сам JavaScript уже имеет готовое решение для этой задачи.
3. **Выполняется ли `useEffect` после каждого рендера?**
   Разумеется! По умолчанию он будет выполняться после каждого рендера и обновления. Вместо того, чтобы воспринимать это с позиции «монтирования» и «обновления», мы советуем просто иметь в виду, что эффекты выполняются после каждого рендера. React гарантирует, что он запустит эффект только после того, как DOM уже обновился. Информация [как настраивать это](https://ru.reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects)

**Пример использования хука `useEffect`:**
Вы должно быть подумали, что нам потребуется отдельный эффект для выполнения сброса. Так как код для оформления и отмены подписки тесно связан с `useEffect`, мы решили объединить их. Если ваш эффект возвращает функцию, React выполнит её только тогда, когда наступит время сбросить эффект.

**Совет**
_Нам не нужно возвращать именованную функцию из эффекта. Мы назвали её «сбросом», чтобы объяснить её предназначение. Вы можете по желанию возвратить стрелочную функцию или назвать её как-то по-другому._

```js
import React, { useState, useEffect } from "react";

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);

    // Указываем, как сбросить этот эффект:
    return function cleanup() {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) {
    return "Загрузка...";
  }

  return isOnline ? "В сети" : "Не в сети";
}
```

1. **Зачем мы вернули функцию из нашего эффекта?**
   Это необязательный механизм сброса эффектов. Каждый эффект может возвратить функцию, которая сбросит его. Это даёт нам возможность объединить вместе логику оформления и отмены подписки. Они, всё-таки, часть одного и того же эффекта!
2. **Когда именно React будет сбрасывать эффект?**
   React будет сбрасывать эффект перед тем, как компонент размонтируется. Однако, как мы уже знаем, эффекты выполняются не один раз, а при каждом рендере. Вот почему React *также* сбрасывает эффект из предыдущего рендера, перед тем, как запустить следующий.

**Кратко три применения:**

Стоит отметить, что **useEffect** использует поверхностное (shallow) сравнение значений зависимостей.

- Функция обратного вызова будет выполняться после каждой визуализации, если нет массива зависимостей.

```ts
// Буду все вополнять когда элементы ререндерется
useEffect(() => {
  NameMethod();
});
```

- Если есть пустой массив зависимостей, функция обратного вызова будет запущена только один раз после первой визуализации.

```ts
// Вузовусь один раз
useEffect(() => {
  // Любой код с работой DOM элементов, поэтому можно сделать addEventListiner
  // Также стоит убирать прослушивание собыйти чтобы не нагружать клиент
}, []);
```

- Если есть массив зависимостей со значениями свойств или переменной состояния, функция обратного вызова будет выполняться только при изменении этих значений.

```ts
const { state, setState } = useState<string>("");
// Вузовусь когда изменится state, который я отслеживаю
useEffect(() => {
  setState("State изменился");
}, [state]);
```

---

[Полная информация](https://ru.reactjs.org/docs/hooks-effect.html#explanation-why-effects-run-on-each-update), [Хорошая статья](https://habr.com/ru/companies/rshb/articles/687364/)
