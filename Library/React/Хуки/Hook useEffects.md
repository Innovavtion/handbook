**Hook Effects (Хуки Эффекта)** используется вместо `componentDidMount - запускается после того, как компонент отрендерился в DOM` и `componentDidUpdate - вызывается сразу после обновления, не вызывается при первом рендере`.

**Использование хука `useEffect`:**
1. **Что же делает `useEffect`?**
	Используя этот хук, вы говорите React сделать что-то после рендера. React запомнит функцию (то есть «эффект»), которую вы передали и вызовет её после того, как внесёт все изменения в DOM. В этом эффекте мы устанавливаем заголовок документа, но мы также можем выполнить запрос данных или вызвать какой-нибудь императивный API.
2. **Почему же мы вызываем `useEffect` непосредственно внутри компонента?**
	Это даёт нам доступ к переменной состояния `count` (или любым другим пропсам) прямиком из эффекта. Нам не нужен специальный API для доступа к этой переменной — она уже находится у нас в области видимости функции. Хуки используют JavaScript-замыкания, и таким образом, им не нужен специальный API для React, поскольку сам JavaScript уже имеет готовое решение для этой задачи.
3. **Выполняется ли `useEffect` после каждого рендера?**
	Разумеется! По умолчанию он будет выполняться после каждого рендера и обновления. Вместо того, чтобы воспринимать это с позиции «монтирования» и «обновления», мы советуем просто иметь в виду, что эффекты выполняются после каждого рендера. React гарантирует, что он запустит эффект только после того, как DOM уже обновился. Информация [как настраивать это](https://ru.reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects)

**Пример использования хука `useEffect`:**
	Вы должно быть подумали, что нам потребуется отдельный эффект для выполнения сброса. Так как код для оформления и отмены подписки тесно связан с `useEffect`, мы решили объединить их. Если ваш эффект возвращает функцию, React выполнит её только тогда, когда наступит время сбросить эффект.

**Совет**
*Нам не нужно возвращать именованную функцию из эффекта. Мы назвали её «сбросом», чтобы объяснить её предназначение. Вы можете по желанию возвратить стрелочную функцию или назвать её как-то по-другому.*

```js
import React, { useState, useEffect } from 'react';

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() => {    
	function handleStatusChange(status) {      
		setIsOnline(status.isOnline);    
	}   
	
	ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
	    
	// Указываем, как сбросить этот эффект:     
	return function cleanup() {
		ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);    
	}; 
  });

  if (isOnline === null) {
	return 'Загрузка...';
  }
  
  return isOnline ? 'В сети' : 'Не в сети';
}
```

1. **Зачем мы вернули функцию из нашего эффекта?**
	Это необязательный механизм сброса эффектов. Каждый эффект может возвратить функцию, которая сбросит его. Это даёт нам возможность объединить вместе логику оформления и отмены подписки. Они, всё-таки, часть одного и того же эффекта!
2. **Когда именно React будет сбрасывать эффект?**
	React будет сбрасывать эффект перед тем, как компонент размонтируется. Однако, как мы уже знаем, эффекты выполняются не один раз, а при каждом рендере. Вот почему React _также_ сбрасывает эффект из предыдущего рендера, перед тем, как запустить следующий.

[Полная информация](https://ru.reactjs.org/docs/hooks-effect.html#explanation-why-effects-run-on-each-update)

